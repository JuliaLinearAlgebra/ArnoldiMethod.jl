<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · ArnoldiMethod.jl</title><meta name="title" content="Getting started · ArnoldiMethod.jl"/><meta property="og:title" content="Getting started · ArnoldiMethod.jl"/><meta property="twitter:title" content="Getting started · ArnoldiMethod.jl"/><meta name="description" content="Documentation for ArnoldiMethod.jl."/><meta property="og:description" content="Documentation for ArnoldiMethod.jl."/><meta property="twitter:description" content="Documentation for ArnoldiMethod.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ArnoldiMethod.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../theory/">Theory</a></li><li><span class="tocitem">Using ArnoldiMethod.jl</span><ul><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Installing"><span>Installing</span></a></li><li><a class="tocitem" href="#Construct-a-partial-Schur-decomposition"><span>Construct a partial Schur decomposition</span></a></li><li><a class="tocitem" href="#From-a-Schur-decomposition-to-an-eigendecomposition"><span>From a Schur decomposition to an eigendecomposition</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#The-PartialSchur-and-History-structs"><span>The PartialSchur and History structs</span></a></li></ul></li><li><a class="tocitem" href="../02_spectral_transformations/">Transformations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Using ArnoldiMethod.jl</a></li><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl/blob/master/docs/src/usage/01_getting_started.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="getting_started"><a class="docs-heading-anchor" href="#getting_started">Getting started</a><a id="getting_started-1"></a><a class="docs-heading-anchor-permalink" href="#getting_started" title="Permalink"></a></h1><h2 id="Installing"><a class="docs-heading-anchor" href="#Installing">Installing</a><a id="Installing-1"></a><a class="docs-heading-anchor-permalink" href="#Installing" title="Permalink"></a></h2><p>In Julia open the package manager in the REPL via <code>]</code> and run:</p><pre><code class="language-julia hljs">(v1.6) pkg&gt; add ArnoldiMethod</code></pre><p>Then use the package.</p><pre><code class="language-julia hljs">using ArnoldiMethod</code></pre><h2 id="Construct-a-partial-Schur-decomposition"><a class="docs-heading-anchor" href="#Construct-a-partial-Schur-decomposition">Construct a partial Schur decomposition</a><a id="Construct-a-partial-Schur-decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-a-partial-Schur-decomposition" title="Permalink"></a></h2><p>ArnoldiMethod.jl exports the <code>partialschur</code> function which can be used to  obtain a partial Schur decomposition of any matrix <code>A</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArnoldiMethod.partialschur" href="#ArnoldiMethod.partialschur"><code>ArnoldiMethod.partialschur</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partialschur(A; nev, which, tol, mindim, maxdim, restarts) → PartialSchur, History</code></pre><p>Find <code>nev</code> approximate eigenpairs of <code>A</code> with eigenvalues near a specified target.</p><p>The matrix <code>A</code> can be any linear map that implements <code>mul!(y, A, x)</code>, <code>eltype</code> and <code>size</code>.</p><p>The method will run iteratively until the eigenpairs are approximated to the prescribed tolerance or until <code>restarts</code> restarts have passed.</p><p><strong>Arguments</strong></p><p>The most important keyword arguments:</p><table><tr><th style="text-align: right">Keyword</th><th style="text-align: left">Type</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>nev</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>min(6, size(A, 1))</code></td><td style="text-align: left">Number of eigenvalues</td></tr><tr><td style="text-align: right"><code>which</code></td><td style="text-align: left"><code>Target</code></td><td style="text-align: left"><code>LM()</code></td><td style="text-align: left">One of <code>LM()</code>, <code>LR()</code>, <code>SR()</code>, <code>LI()</code>, <code>SI()</code>, see below.</td></tr><tr><td style="text-align: right"><code>tol</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left"><code>√eps</code></td><td style="text-align: left">Tolerance for convergence: ‖Ax - xλ‖₂ &lt; tol * ‖λ‖</td></tr></table><p>The target <code>which</code> can be any of <code>subtypes(ArnoldiMethod.Target)</code>:</p><table><tr><th style="text-align: right">Target</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>LM()</code></td><td style="text-align: left">Largest magnitude: <code>abs(λ)</code> is largest</td></tr><tr><td style="text-align: right"><code>LR()</code></td><td style="text-align: left">Largest real part: <code>real(λ)</code> is largest</td></tr><tr><td style="text-align: right"><code>SR()</code></td><td style="text-align: left">Smallest real part: <code>real(λ)</code> is smallest</td></tr><tr><td style="text-align: right"><code>LI()</code></td><td style="text-align: left">Largest imaginary part: <code>imag(λ)</code> is largest</td></tr><tr><td style="text-align: right"><code>SI()</code></td><td style="text-align: left">Smallest imaginary part: <code>imag(λ)</code> is smallest</td></tr></table><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The targets <code>LI()</code> and <code>SI()</code> only make sense in complex arithmetic. In real arithmetic <code>λ</code> is an eigenvalue iff <code>conj(λ)</code> is an eigenvalue and this  conjugate pair converges simultaneously.</p></div></div><p><strong>Return values</strong></p><p>The function returns a tuple</p><pre><code class="language-julia hljs">decomp, history = partialschur(A, ...)</code></pre><p>where <code>decomp</code> is a <a href="#ArnoldiMethod.PartialSchur"><code>PartialSchur</code></a> struct which  forms a partial Schur decomposition of <code>A</code> to a prescribed tolerance:</p><pre><code class="language-julia hljs">&gt; norm(A * decomp.Q - decomp.Q * decomp.R)</code></pre><p><code>history</code> is a <a href="#ArnoldiMethod.History"><code>History</code></a> struct that holds some basic information about convergence of the method:</p><pre><code class="language-julia hljs">&gt; history.converged
true
&gt; @show history
Converged after 359 matrix-vector products</code></pre><p><strong>Advanced usage</strong></p><p>Further there are advanced keyword arguments for tuning the algorithm:</p><table><tr><th style="text-align: right">Keyword</th><th style="text-align: left">Type</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>mindim</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>min(max(10, nev), size(A,1))</code></td><td style="text-align: left">Minimum Krylov dimension (≥ nev)</td></tr><tr><td style="text-align: right"><code>maxdim</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>min(max(20, 2nev), size(A,1))</code></td><td style="text-align: left">Maximum Krylov dimension (≥ min)</td></tr><tr><td style="text-align: right"><code>restarts</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>200</code></td><td style="text-align: left">Maximum number of restarts</td></tr></table><p>When the algorithm does not converge, one can increase <code>restarts</code>. When the  algorithm converges too slowly, one can play with <code>mindim</code> and <code>maxdim</code>. It is  suggested to keep <code>mindim</code> equal to or slightly larger than <code>nev</code>, and <code>maxdim</code> is usually about two times <code>mindim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl/blob/31fd388fdd375b0f766b39bf8e02e99177764358/src/run.jl#L14-L93">source</a></section></article><h2 id="From-a-Schur-decomposition-to-an-eigendecomposition"><a class="docs-heading-anchor" href="#From-a-Schur-decomposition-to-an-eigendecomposition">From a Schur decomposition to an eigendecomposition</a><a id="From-a-Schur-decomposition-to-an-eigendecomposition-1"></a><a class="docs-heading-anchor-permalink" href="#From-a-Schur-decomposition-to-an-eigendecomposition" title="Permalink"></a></h2><p>The eigenvalues and eigenvectors are obtained from the Schur form with the  <code>partialeigen</code> function that is exported by ArnoldiMethod.jl:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArnoldiMethod.partialeigen" href="#ArnoldiMethod.partialeigen"><code>ArnoldiMethod.partialeigen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partialeigen(P::PartialSchur) → (Vector{&lt;:Union{Real,Complex}}, Matrix{&lt;:Union{Real,Complex}})</code></pre><p>Transforms a partial Schur decomposition into an eigendecomposition.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For real-symmetric and Hermitian matrices the Schur vectors coincide with  the eigenvectors, and hence it is not necessary to call this function in  that case.</p></div></div><p>The method still relies on LAPACK to compute the eigenvectors of the (quasi) upper triangular matrix <code>R</code> from the partial Schur decomposition.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method is currently type unstable for real matrices, since we have not yet decided how to deal with complex conjugate pairs of eigenvalues. E.g. if almost all eigenvalues are real, but there are just a few conjugate  pairs, should all eigenvectors be complex-valued?</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl/blob/31fd388fdd375b0f766b39bf8e02e99177764358/src/eigvals.jl#L67-L87">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Here we compute the first ten eigenvalues and eigenvectors of a tridiagonal sparse matrix.</p><pre><code class="language-julia hljs">julia&gt; using ArnoldiMethod, LinearAlgebra, SparseArrays
julia&gt; A = spdiagm(
           -1 =&gt; fill(-1.0, 99),
            0 =&gt; fill(2.0, 100), 
            1 =&gt; fill(-1.0, 99)
       );
julia&gt; decomp, history = partialschur(A, nev=10, tol=1e-6, which=SR());
julia&gt; decomp
PartialSchur decomposition (Float64) of dimension 10
eigenvalues:
10-element Array{Complex{Float64},1}:
 0.0009674354160236865 + 0.0im
  0.003868805732811139 + 0.0im
  0.008701304061962657 + 0.0im
   0.01546025527344699 + 0.0im
  0.024139120518486677 + 0.0im
    0.0347295035554728 + 0.0im
   0.04722115887278571 + 0.0im
   0.06160200160067088 + 0.0im
    0.0778581192025522 + 0.0im
   0.09597378493453936 + 0.0im
julia&gt; history
Converged: 10 of 10 eigenvalues in 174 matrix-vector products
julia&gt; norm(A * decomp.Q - decomp.Q * decomp.R)
6.39386920955869e-8
julia&gt; λs, X = partialeigen(decomp);
julia&gt; norm(A * X - X * Diagonal(λs))
6.393869211477937e-8</code></pre><h2 id="The-PartialSchur-and-History-structs"><a class="docs-heading-anchor" href="#The-PartialSchur-and-History-structs">The PartialSchur and History structs</a><a id="The-PartialSchur-and-History-structs-1"></a><a class="docs-heading-anchor-permalink" href="#The-PartialSchur-and-History-structs" title="Permalink"></a></h2><p>For completeness, the return values of the <a href="#ArnoldiMethod.partialschur"><code>partialschur</code></a> function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArnoldiMethod.PartialSchur" href="#ArnoldiMethod.PartialSchur"><code>ArnoldiMethod.PartialSchur</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartialSchur(Q, R, eigenvalues)</code></pre><p>Holds an orthonormal basis <code>Q</code> and a (quasi) upper triangular matrix <code>R</code>.</p><p>For convenience the eigenvalues that appear on the diagonal of <code>R</code> are also  listed as <code>eigenvalues</code>, which is in particular useful in the case of real  matrices with complex eigenvalues. Note that the eigenvalues are always a  complex, even when the matrix <code>R</code> is real.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl/blob/31fd388fdd375b0f766b39bf8e02e99177764358/src/ArnoldiMethod.jl#L57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArnoldiMethod.History" href="#ArnoldiMethod.History"><code>ArnoldiMethod.History</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">History(mvproducts, nconverged, converged, nev)</code></pre><p>History shows whether the method has converged (when <code>nconverged</code> ≥ <code>nev</code>) and how many matrix-vector products were necessary to do so.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl/blob/31fd388fdd375b0f766b39bf8e02e99177764358/src/run.jl#L134-L139">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../theory/">« Theory</a><a class="docs-footer-nextpage" href="../02_spectral_transformations/">Transformations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 12 February 2024 21:32">Monday 12 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
