<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using ArnoldiMethod.jl · ArnoldiMethod.jl</title><meta name="title" content="Using ArnoldiMethod.jl · ArnoldiMethod.jl"/><meta property="og:title" content="Using ArnoldiMethod.jl · ArnoldiMethod.jl"/><meta property="twitter:title" content="Using ArnoldiMethod.jl · ArnoldiMethod.jl"/><meta name="description" content="Documentation for ArnoldiMethod.jl."/><meta property="og:description" content="Documentation for ArnoldiMethod.jl."/><meta property="twitter:description" content="Documentation for ArnoldiMethod.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ArnoldiMethod.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../theory/">Theory</a></li><li class="is-active"><a class="tocitem" href>Using ArnoldiMethod.jl</a><ul class="internal"><li><a class="tocitem" href="#Installing"><span>Installing</span></a></li><li><a class="tocitem" href="#Construct-a-partial-Schur-decomposition"><span>Construct a partial Schur decomposition</span></a></li><li><a class="tocitem" href="#From-a-Schur-decomposition-to-an-eigendecomposition"><span>From a Schur decomposition to an eigendecomposition</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#The-PartialSchur-and-History-structs"><span>The PartialSchur and History structs</span></a></li><li><a class="tocitem" href="#Bringing-problems-to-standard-form"><span>Bringing problems to standard form</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Using ArnoldiMethod.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using ArnoldiMethod.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl/blob/master/docs/src/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="getting_started"><a class="docs-heading-anchor" href="#getting_started">Getting started</a><a id="getting_started-1"></a><a class="docs-heading-anchor-permalink" href="#getting_started" title="Permalink"></a></h1><h2 id="Installing"><a class="docs-heading-anchor" href="#Installing">Installing</a><a id="Installing-1"></a><a class="docs-heading-anchor-permalink" href="#Installing" title="Permalink"></a></h2><p>In Julia open the package manager in the REPL via <code>]</code> and run:</p><pre><code class="language-julia hljs">(v1.6) pkg&gt; add ArnoldiMethod</code></pre><p>Then use the package.</p><pre><code class="language-julia hljs">using ArnoldiMethod</code></pre><h2 id="Construct-a-partial-Schur-decomposition"><a class="docs-heading-anchor" href="#Construct-a-partial-Schur-decomposition">Construct a partial Schur decomposition</a><a id="Construct-a-partial-Schur-decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-a-partial-Schur-decomposition" title="Permalink"></a></h2><p>ArnoldiMethod.jl exports the <code>partialschur</code> function which can be used to  obtain a partial Schur decomposition of any matrix <code>A</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArnoldiMethod.partialschur" href="#ArnoldiMethod.partialschur"><code>ArnoldiMethod.partialschur</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partialschur(A; nev, which, tol, mindim, maxdim, restarts) → PartialSchur, History</code></pre><p>Find <code>nev</code> approximate eigenpairs of <code>A</code> with eigenvalues near a specified target.</p><p>The matrix <code>A</code> can be any linear map that implements <code>mul!(y, A, x)</code>, <code>eltype</code> and <code>size</code>.</p><p>The method will run iteratively until the eigenpairs are approximated to the prescribed tolerance or until <code>restarts</code> restarts have passed.</p><p><strong>Arguments</strong></p><p>The most important keyword arguments:</p><table><tr><th style="text-align: right">Keyword</th><th style="text-align: left">Type</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>nev</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>min(6, size(A, 1))</code></td><td style="text-align: left">Number of eigenvalues</td></tr><tr><td style="text-align: right"><code>which</code></td><td style="text-align: left"><code>Symbol</code> or <code>Target</code></td><td style="text-align: left"><code>:LM</code></td><td style="text-align: left">One of <code>:LM</code>, <code>:LR</code>, <code>:SR</code>, <code>:LI</code>, <code>:SI</code>, see below.</td></tr><tr><td style="text-align: right"><code>tol</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left"><code>√eps</code></td><td style="text-align: left">Tolerance for convergence: ‖Ax - xλ‖₂ &lt; tol * ‖λ‖</td></tr></table><p>The target <code>which</code> can be any of:</p><table><tr><th style="text-align: right">Target</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>:LM</code> or <code>LM()</code></td><td style="text-align: left">Largest magnitude: <code>abs(λ)</code> is largest</td></tr><tr><td style="text-align: right"><code>:LR</code> or <code>LR()</code></td><td style="text-align: left">Largest real part: <code>real(λ)</code> is largest</td></tr><tr><td style="text-align: right"><code>:SR</code> or <code>SR()</code></td><td style="text-align: left">Smallest real part: <code>real(λ)</code> is smallest</td></tr><tr><td style="text-align: right"><code>:LI</code> or <code>LI()</code></td><td style="text-align: left">Largest imaginary part: <code>imag(λ)</code> is largest</td></tr><tr><td style="text-align: right"><code>:SI</code> or <code>SI()</code></td><td style="text-align: left">Smallest imaginary part: <code>imag(λ)</code> is smallest</td></tr></table><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The targets <code>:LI</code> and <code>:SI</code> only make sense in complex arithmetic. In real arithmetic <code>λ</code> is an eigenvalue iff <code>conj(λ)</code> is an eigenvalue and this  conjugate pair converges simultaneously.</p></div></div><p><strong>Return values</strong></p><p>The function returns a tuple</p><pre><code class="language-julia hljs">decomp, history = partialschur(A, ...)</code></pre><p>where <code>decomp</code> is a <a href="#ArnoldiMethod.PartialSchur"><code>PartialSchur</code></a> struct which  forms a partial Schur decomposition of <code>A</code> to a prescribed tolerance:</p><pre><code class="language-julia hljs">&gt; norm(A * decomp.Q - decomp.Q * decomp.R)</code></pre><p><code>history</code> is a <a href="#ArnoldiMethod.History"><code>History</code></a> struct that holds some basic information about convergence of the method:</p><pre><code class="language-julia hljs">&gt; history.converged
true
&gt; @show history
Converged after 359 matrix-vector products</code></pre><p><strong>Advanced usage</strong></p><p>Further there are advanced keyword arguments for tuning the algorithm:</p><table><tr><th style="text-align: right">Keyword</th><th style="text-align: left">Type</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>mindim</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>min(max(10, nev), size(A,1))</code></td><td style="text-align: left">Minimum Krylov dimension (≥ nev)</td></tr><tr><td style="text-align: right"><code>maxdim</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>min(max(20, 2nev), size(A,1))</code></td><td style="text-align: left">Maximum Krylov dimension (≥ min)</td></tr><tr><td style="text-align: right"><code>restarts</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>200</code></td><td style="text-align: left">Maximum number of restarts</td></tr></table><p>When the algorithm does not converge, one can increase <code>restarts</code>. When the  algorithm converges too slowly, one can play with <code>mindim</code> and <code>maxdim</code>. It is  suggested to keep <code>mindim</code> equal to or slightly larger than <code>nev</code>, and <code>maxdim</code> is usually about two times <code>mindim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl/blob/4c67542a661eaa1c21649746c6a5508de7cd7b4e/src/run.jl#L14-L93">source</a></section></article><h2 id="From-a-Schur-decomposition-to-an-eigendecomposition"><a class="docs-heading-anchor" href="#From-a-Schur-decomposition-to-an-eigendecomposition">From a Schur decomposition to an eigendecomposition</a><a id="From-a-Schur-decomposition-to-an-eigendecomposition-1"></a><a class="docs-heading-anchor-permalink" href="#From-a-Schur-decomposition-to-an-eigendecomposition" title="Permalink"></a></h2><p>The eigenvalues and eigenvectors are obtained from the Schur form with the  <code>partialeigen</code> function that is exported by ArnoldiMethod.jl:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArnoldiMethod.partialeigen" href="#ArnoldiMethod.partialeigen"><code>ArnoldiMethod.partialeigen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partialeigen(P::PartialSchur) → (Vector{&lt;:Union{Real,Complex}}, Matrix{&lt;:Union{Real,Complex}})</code></pre><p>Transforms a partial Schur decomposition into an eigendecomposition.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For real-symmetric and complex-Hermitian matrices the Schur vectors coincide with the eigenvectors and the R matrix is diagonal, and hence it is not necessary to call this function in that case.</p><p>In fact, in case of real-symmetric and complex-Hermitian matrices <em>with repeated eigenvalues</em>, calling <code>partialeigen</code> may be undesirable, as it can return eigenvectors that are not orthogonal. The Schur vectors on the other hand are orthogonal by construction.</p></div></div><p>The method still relies on LAPACK to compute the eigenvectors of the (quasi) upper triangular matrix <code>R</code> from the partial Schur decomposition.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method is currently type unstable for real matrices, since we have not yet decided how to deal with complex conjugate pairs of eigenvalues. E.g. if almost all eigenvalues are real, but there are just a few conjugate  pairs, should all eigenvectors be complex-valued?</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl/blob/4c67542a661eaa1c21649746c6a5508de7cd7b4e/src/eigvals.jl#L67-L91">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Here we compute the first ten eigenvalues and eigenvectors of a tridiagonal sparse matrix.</p><pre><code class="language-julia hljs">julia&gt; using ArnoldiMethod, LinearAlgebra, SparseArrays

julia&gt; A = spdiagm(
           -1 =&gt; fill(-1.0, 99),
            0 =&gt; fill(2.0, 100), 
            1 =&gt; fill(-1.0, 99)
       );

julia&gt; decomp, history = partialschur(A, nev=10, tol=1e-6, which=:SR);

julia&gt; decomp
PartialSchur decomposition (Float64) of dimension 10
eigenvalues:
10-element Array{Complex{Float64},1}:
 0.0009674354160236865 + 0.0im
  0.003868805732811139 + 0.0im
  0.008701304061962657 + 0.0im
   0.01546025527344699 + 0.0im
  0.024139120518486677 + 0.0im
    0.0347295035554728 + 0.0im
   0.04722115887278571 + 0.0im
   0.06160200160067088 + 0.0im
    0.0778581192025522 + 0.0im
   0.09597378493453936 + 0.0im

julia&gt; history
Converged: 10 of 10 eigenvalues in 174 matrix-vector products

julia&gt; norm(A * decomp.Q - decomp.Q * decomp.R)
6.39386920955869e-8

julia&gt; λs, X = partialeigen(decomp);

julia&gt; norm(A * X - X * Diagonal(λs))
6.393869211477937e-8</code></pre><h2 id="The-PartialSchur-and-History-structs"><a class="docs-heading-anchor" href="#The-PartialSchur-and-History-structs">The PartialSchur and History structs</a><a id="The-PartialSchur-and-History-structs-1"></a><a class="docs-heading-anchor-permalink" href="#The-PartialSchur-and-History-structs" title="Permalink"></a></h2><p>For completeness, the return values of the <a href="#ArnoldiMethod.partialschur"><code>partialschur</code></a> function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArnoldiMethod.PartialSchur" href="#ArnoldiMethod.PartialSchur"><code>ArnoldiMethod.PartialSchur</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartialSchur(Q, R, eigenvalues)</code></pre><p>Holds an orthonormal basis <code>Q</code> and a (quasi) upper triangular matrix <code>R</code>.</p><p>For convenience the eigenvalues that appear on the diagonal of <code>R</code> are also  listed as <code>eigenvalues</code>, which is in particular useful in the case of real  matrices with complex eigenvalues. Note that the eigenvalues are always a  complex, even when the matrix <code>R</code> is real.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl/blob/4c67542a661eaa1c21649746c6a5508de7cd7b4e/src/ArnoldiMethod.jl#L57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ArnoldiMethod.History" href="#ArnoldiMethod.History"><code>ArnoldiMethod.History</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">History(mvproducts, nconverged, converged, nev)</code></pre><p>History shows whether the method has converged (when <code>nconverged</code> ≥ <code>nev</code>) and how many matrix-vector products were necessary to do so.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl/blob/4c67542a661eaa1c21649746c6a5508de7cd7b4e/src/run.jl#L142-L147">source</a></section></article><h2 id="Bringing-problems-to-standard-form"><a class="docs-heading-anchor" href="#Bringing-problems-to-standard-form">Bringing problems to standard form</a><a id="Bringing-problems-to-standard-form-1"></a><a class="docs-heading-anchor-permalink" href="#Bringing-problems-to-standard-form" title="Permalink"></a></h2><p>ArnoldiMethod.jl by default can only compute an approximate, partial Schur decomposition <span>$AQ = QR$</span> and (from there) a partial eigendecomposition <span>$AX = XD$</span> of a matrix <span>$A$</span>, for <em>extremal</em> eigenvalues <span>$d_{ii}$</span>.</p><p>Whenever one targets eigenvalues close to a specific point in the complex plane, or whenever one solves generalized eigenvalue problems, suitable transformations will enable you to recast the problem into something that ArnoldiMethod.jl can  handle well. In this section we provide some examples.</p><h3 id="Shift-and-invert-with-LinearMaps.jl"><a class="docs-heading-anchor" href="#Shift-and-invert-with-LinearMaps.jl">Shift-and-invert with LinearMaps.jl</a><a id="Shift-and-invert-with-LinearMaps.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Shift-and-invert-with-LinearMaps.jl" title="Permalink"></a></h3><p>To find eigenvalues closest to the origin of <span>$A$</span>, one can find the eigenvalues of largest magnitude of <span>$A^{-1}$</span>. <a href="https://github.com/Jutho/LinearMaps.jl">LinearMaps.jl</a>  is a neat way to implement this.</p><pre><code class="language-julia hljs">using ArnoldiMethod, LinearAlgebra, LinearMaps

# Define a matrix whose eigenvalues you want
A = rand(100,100)

# Factorizes A and builds a linear map that applies inv(A) to a vector.
function construct_linear_map(A)
    F = factorize(A)
    LinearMap{eltype(A)}((y, x) -&gt; ldiv!(y, F, x), size(A,1), ismutating=true)
end

# Target the largest eigenvalues of the inverted problem
decomp, = partialschur(construct_linear_map(A), nev=4, tol=1e-5, restarts=100, which=:LM)
λs_inv, X = partialeigen(decomp)

# Eigenvalues have to be inverted to find the smallest eigenvalues of the non-inverted problem.
λs = 1 ./ λs_inv
 
# Show that Ax = xλ
@show norm(A * X - X * Diagonal(λs)) # 7.38473677258669e-6</code></pre><h3 id="Shift-and-invert-for-generalized-eigenvalue-problems"><a class="docs-heading-anchor" href="#Shift-and-invert-for-generalized-eigenvalue-problems">Shift-and-invert for generalized eigenvalue problems</a><a id="Shift-and-invert-for-generalized-eigenvalue-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Shift-and-invert-for-generalized-eigenvalue-problems" title="Permalink"></a></h3><p>When targeting the eigenvalues closest to the origin of a generalized eigenvalue problem <span>$Ax = Bx\lambda$</span>, one can apply the shift-and-invert trick, recasting  the problem to <span>$A^{-1}Bx = x\theta$</span> where <span>$\lambda = 1 / \theta$</span>.</p><pre><code class="language-julia hljs">using ArnoldiMethod, LinearAlgebra, LinearMaps

# Define the matrices of the generalized eigenvalue problem
A, B = rand(100, 100), rand(100, 100)

struct ShiftAndInvert{TA,TB,TT}
    A_lu::TA
    B::TB
    temp::TT
end

function (M::ShiftAndInvert)(y, x)
    mul!(M.temp, M.B, x)
    ldiv!(y, M.A_lu, M.temp)
end

function construct_linear_map(A, B)
    a = ShiftAndInvert(factorize(A), B, Vector{eltype(A)}(undef, size(A, 1)))
    LinearMap{eltype(A)}(a, size(A, 1), ismutating = true)
end

# Target the largest eigenvalues of the inverted problem
decomp, = partialschur(
    construct_linear_map(A, B),
    nev = 4,
    tol = 1e-5,
    restarts = 100,
    which = :LM,
)
λs_inv, X = partialeigen(decomp)

# Eigenvalues have to be inverted to find the smallest eigenvalues of the non-inverted problem.
λs = 1 ./ λs_inv

# Show that Ax = Bxλ
@show norm(A * X - B * X * Diagonal(λs)) # 2.8043149027575927e-6</code></pre><h3 id="Largest-eigenvalues-of-a-generalized-eigenvalue-problem-with-symmetric-positive-definite-B"><a class="docs-heading-anchor" href="#Largest-eigenvalues-of-a-generalized-eigenvalue-problem-with-symmetric-positive-definite-B">Largest eigenvalues of a generalized eigenvalue problem with symmetric positive-definite B</a><a id="Largest-eigenvalues-of-a-generalized-eigenvalue-problem-with-symmetric-positive-definite-B-1"></a><a class="docs-heading-anchor-permalink" href="#Largest-eigenvalues-of-a-generalized-eigenvalue-problem-with-symmetric-positive-definite-B" title="Permalink"></a></h3><p>When <span>$B$</span> is a symmetric positive-definite matrix, and it&#39;s affordable to compute a Cholesky decomposition of <span>$B$</span>, one can use ArnoldiMethod.jl to create a partial Schur decomposition of <span>$A$</span> where the Schur vectors are <span>$B$</span>-orthonormal:</p><p>Solve <span>$Q^*AQ = R$</span> where <span>$Q^*BQ = I$</span> and <span>$R$</span> is upper triangular. If <span>$A = A^*$</span> as well, then <span>$R$</span> is diagonal and we have a partial eigendecomposition of <span>$A$</span>.</p><p>First we take the Cholesky decomposition <span>$B = LL^*$</span> and plug it into <span>$AQ = BQR$</span> to obtain <span>$L^{-*}AL^{-1}L^*Q = L^*QR$</span>.</p><p>Then define <span>$C = L^{-*}AL^{-1}$</span> and <span>$Y = L^*Q$</span> and we have a standard Schur decomposition <span>$CY = YR$</span> which we can solve using <code>partialschur</code>.</p><p>The linear map <span>$C$</span> can be defined as follows:</p><pre><code class="language-julia hljs">using ArnoldiMethod, LinearAlgebra, LinearMaps
struct WithBInnerProduct{TA,TL}
    A::TA
    L::TL
end

function (M::WithBInnerProduct)(y, x)
    # Julia unfortunately does not have in-place CHOLMOD solve, so this is far from optimal.
    tmp = M.L \ x
    mul!(y, M.A, tmp)
    y .= M.L&#39; \ y
    return y
end

# Define the matrices of the generalized eigenvalue problem
A = rand(100, 100)
B = Diagonal(range(1.0, 2.0, length = 100))

# Reformulate the problem as standard Schur decomposition
F = cholesky(B)
linear_map = LinearMap{eltype(A)}(WithBInnerProduct(A, F.L), size(A, 1), ismutating = true)
decomp, info = partialschur(linear_map, nev = 4, which = :LM, tol = 1e-10)

# Translate back to the original problem
Q = F.L&#39; \ decomp.Q

@show norm(Q&#39; * A * Q - decomp.R)  # 3.883933945390996e-14
@show norm(Q&#39; * B * Q - I)  # 3.1672155003480583e-15</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/">« Theory</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 13 February 2024 10:23">Tuesday 13 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
