var documenterSearchIndex = {"docs":
[{"location":"#ArnoldiMethod.jl","page":"Home","title":"ArnoldiMethod.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ArnoldiMethod.jl provides an iterative method to find a few approximate  solutions to the eigenvalue problem in standard form:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ax = xlambda","category":"page"},{"location":"","page":"Home","title":"Home","text":"where A is a general matrix of size n times n; and x in mathbbC^n and lambda in mathbbC are eigenvectors and eigenvalues respectively. By  general matrix we mean that A has no special structure. It can be symmetric or non-symmetric and either real or complex.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The method is matrix-free, meaning that it only requires multiplication with  the matrix A.","category":"page"},{"location":"#Installing","page":"Home","title":"Installing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In Julia open the package manager in the REPL via ] and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.6) pkg> add ArnoldiMethod","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then use the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ArnoldiMethod","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package exports just two functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"partialschur to compute a stable basis for an eigenspace;\npartialeigen to compute an eigendecomposition from a partial Schur decomposition.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here we compute the first ten eigenvalues and eigenvectors of a tridiagonal sparse matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ArnoldiMethod, LinearAlgebra, SparseArrays\n\njulia> A = spdiagm(\n           -1 => fill(-1.0, 99),\n            0 => fill(2.0, 100), \n            1 => fill(-1.0, 99)\n       );\n\njulia> decomp, history = partialschur(A, nev=10, tol=1e-6, which=:SR);\n\njulia> decomp\nPartialSchur decomposition (Float64) of dimension 10\neigenvalues:\n10-element Array{Complex{Float64},1}:\n 0.0009674354160236865 + 0.0im\n  0.003868805732811139 + 0.0im\n  0.008701304061962657 + 0.0im\n   0.01546025527344699 + 0.0im\n  0.024139120518486677 + 0.0im\n    0.0347295035554728 + 0.0im\n   0.04722115887278571 + 0.0im\n   0.06160200160067088 + 0.0im\n    0.0778581192025522 + 0.0im\n   0.09597378493453936 + 0.0im\n\njulia> history\nConverged: 10 of 10 eigenvalues in 174 matrix-vector products\n\njulia> norm(A * decomp.Q - decomp.Q * decomp.R)\n6.39386920955869e-8\n\njulia> λs, X = partialeigen(decomp);\n\njulia> norm(A * X - X * Diagonal(λs))\n6.393869211477937e-8","category":"page"},{"location":"#Partial-Schur-decomposition","page":"Home","title":"Partial Schur decomposition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The partialschur method forms the backbone of the package. It computes an approximate, partial Schur decomposition of a matrix A:","category":"page"},{"location":"","page":"Home","title":"Home","text":"AQ = QR","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Q is orthonormal of size n times textttnev and R is upper  triangular of size textttnev times textttnev with eigenvalues of A on the diagonal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: 2x2 blocks in real arithmetic\nIn real arithmetic R is quasi upper triangular, with 2 times 2 blocks on the diagonal  corresponding to conjugate complex-valued eigenpairs. These 2 times 2 blocks are used for efficiency, since otherwise the entire Schur form would have to use complex arithmetic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: A partial Schur decomposition is often enough\nOften a partial Schur decomposition is all you need, cause it's more stable to compute and work with than a partial eigendecomposition.Also note that for complex Hermitian and real symmetric matrices, the partial Schur form coincides with the partial eigendecomposition (the R matrix is diagonal).","category":"page"},{"location":"","page":"Home","title":"Home","text":"partialschur\npartialschur!","category":"page"},{"location":"#ArnoldiMethod.partialschur","page":"Home","title":"ArnoldiMethod.partialschur","text":"partialschur(A; v1, workspace, nev, which, tol, mindim, maxdim, restarts) → PartialSchur, History\n\nFind nev approximate eigenpairs of A with eigenvalues near a specified target.\n\nThe matrix A can be any linear map that implements mul!(y, A, x), eltype and size.\n\nThe method will run iteratively until the eigenpairs are approximated to the prescribed tolerance or until restarts restarts have passed.\n\nArguments\n\nThe most important keyword arguments:\n\nKeyword Type Default Description\nnev Int min(6, size(A, 1)) Number of eigenvalues\nwhich Symbol or Target :LM One of :LM, :LR, :SR, :LI, :SI, see below.\ntol Real √eps Tolerance for convergence: ‖Ax - xλ‖₂ < tol * ‖λ‖\nv1 AbstractVector nothing Optional starting vector for the Krylov subspace\n\nRegarding the initial vector v1: it will not be mutated, and it does not have to be normalized.\n\nThe target which can be any of:\n\nTarget Description\n:LM or LM() Largest magnitude: abs(λ) is largest\n:LR or LR() Largest real part: real(λ) is largest\n:SR or SR() Smallest real part: real(λ) is smallest\n:LI or LI() Largest imaginary part: imag(λ) is largest\n:SI or SI() Smallest imaginary part: imag(λ) is smallest\n\nNote that as of ArnoldiMethod v0.4, you have to import using ArnoldiMethod: LM explicitly if you do not want to use symbols.\n\nnote: Note\nThe targets :LI and :SI only make sense in complex arithmetic. In real arithmetic λ is an eigenvalue iff conj(λ) is an eigenvalue and this  conjugate pair converges simultaneously.\n\nReturn values\n\nThe function returns a tuple\n\ndecomp, history = partialschur(A, ...)\n\nwhere decomp is a PartialSchur struct which  forms a partial Schur decomposition of A to a prescribed tolerance:\n\n> norm(A * decomp.Q - decomp.Q * decomp.R)\n\nhistory is a History struct that holds some basic information about convergence of the method:\n\n> history.converged\ntrue\n> @show history\nConverged after 359 matrix-vector products\n\nAdvanced usage\n\nFurther there are advanced keyword arguments for tuning the algorithm:\n\nKeyword Type Default Description\nmindim Int min(max(10, nev), size(A,1)) Minimum Krylov dimension (≥ nev)\nmaxdim Int min(max(20, 2nev), size(A,1)) Maximum Krylov dimension (≥ min)\nrestarts Int 200 Maximum number of restarts\n\nWhen the algorithm does not converge, one can increase restarts. When the  algorithm converges too slowly, one can play with mindim and maxdim. It is  suggested to keep mindim equal to or slightly larger than nev, and maxdim is usually about two times mindim.\n\n\n\n\n\n","category":"function"},{"location":"#ArnoldiMethod.partialschur!","page":"Home","title":"ArnoldiMethod.partialschur!","text":"partialschur!(A, arnoldi; start_from, initialize, nev, which, tol, mindim, maxdim, restarts) → PartialSchur, History\n\nThis is a variant of partialschur that operates on a pre-allocated ArnoldiWorkspace instance. This is useful in the following cases:\n\nTo provide an initial partial Schur decomposition. In that case, set start_from to the number of Schur vectors, and partialschur will continue from there. Notice that if you have only one Schur vector, it can be simpler to pass it as v1 instead.\nTo provide a custom array type for the basis of the Krylov subspace, the Hessenberg matrix, and some temporaries.\nTo avoid allocations when calling partialschur repeatedly.\n\nYou can also provide the initial vector that induces the Krylov subspace in the first column arnoldi.V[:, 1]. If you do that, set initialize explicitly to false.\n\nUpon return, note that the PartialSchur struct will contain views of arnoldi.V and arnoldi.H, no copies are made.\n\n\n\n\n\n","category":"function"},{"location":"#Partial-eigendecomposition","page":"Home","title":"Partial eigendecomposition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After computing the partial Schur decomposition, it can be transformed into a partial eigendecomposition via the partialeigen helper function. The basic math is to determine the eigendecomposition of the upper triangular matrix RY = YLambda such that","category":"page"},{"location":"","page":"Home","title":"Home","text":"A(QY) = (QY)Lambda","category":"page"},{"location":"","page":"Home","title":"Home","text":"forms the full eigendecomposition of A, where QY are the eigenvectors and Lambda is a textttnev times textttnev diagonal matrix of eigenvalues.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This step is a relatively cheap post-processing step.","category":"page"},{"location":"","page":"Home","title":"Home","text":"partialeigen","category":"page"},{"location":"#ArnoldiMethod.partialeigen","page":"Home","title":"ArnoldiMethod.partialeigen","text":"partialeigen(P::PartialSchur) → (Vector{<:Union{Real,Complex}}, Matrix{<:Union{Real,Complex}})\n\nTransforms a partial Schur decomposition into an eigendecomposition.\n\nnote: Note\nFor real-symmetric and complex-Hermitian matrices the Schur vectors coincide with the eigenvectors and the R matrix is diagonal, and hence it is not necessary to call this function in that case.In fact, in case of real-symmetric and complex-Hermitian matrices with repeated eigenvalues, calling partialeigen may be undesirable, as it can return eigenvectors that are not orthogonal. The Schur vectors on the other hand are orthogonal by construction.\n\nThe method still relies on LAPACK to compute the eigenvectors of the (quasi) upper triangular matrix R from the partial Schur decomposition.\n\nnote: Note\nThis method is currently type unstable for real matrices, since we have not yet decided how to deal with complex conjugate pairs of eigenvalues. E.g. if almost all eigenvalues are real, but there are just a few conjugate  pairs, should all eigenvectors be complex-valued?\n\n\n\n\n\n","category":"function"},{"location":"#Stopping-criterion","page":"Home","title":"Stopping criterion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ArnoldiMethod.jl considers an approximate eigenpair converged when the  condition","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ax - xlambda_2  texttttollambda","category":"page"},{"location":"","page":"Home","title":"Home","text":"is met, where tol is a user provided tolerance. Note that this stopping  criterion is scale-invariant. For a scaled matrix B = alpha A the same  approximate eigenvector together with the scaled eigenvalue alphalambda  would satisfy the stopping criterion.","category":"page"},{"location":"#The-PartialSchur-and-History-structs","page":"Home","title":"The PartialSchur and History structs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For completeness, the return values of the partialschur function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArnoldiMethod.PartialSchur\nArnoldiMethod.History","category":"page"},{"location":"#ArnoldiMethod.PartialSchur","page":"Home","title":"ArnoldiMethod.PartialSchur","text":"PartialSchur(Q, R, eigenvalues)\n\nHolds an orthonormal basis Q and a (quasi) upper triangular matrix R.\n\nFor convenience the eigenvalues that appear on the diagonal of R are also  listed as eigenvalues, which is in particular useful in the case of real  matrices with complex eigenvalues. Note that the eigenvalues are always  complex, even when the matrix R is real.\n\n\n\n\n\n","category":"type"},{"location":"#ArnoldiMethod.History","page":"Home","title":"ArnoldiMethod.History","text":"History(mvproducts, nconverged, converged, nev)\n\nHistory shows whether the method has converged (when nconverged ≥ nev) and how many matrix-vector products were necessary to do so.\n\n\n\n\n\n","category":"type"},{"location":"#Passing-an-initial-guess","page":"Home","title":"Passing an initial guess","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have a good guess for a target eigenvector, you can potentially speed up the method by passing it through partialschur(A, v1=my_initial_vector). This vector is then used to build the Krylov subspace.","category":"page"},{"location":"#Pre-allocating-and-custom-matrix-types","page":"Home","title":"Pre-allocating and custom matrix types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you call partialschur multiple times, and you want to allocate large arrays and buffers only once ahead of time, you can allocate the relevant matrices manually and pass them to the algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The same can be done if you want to work with custom matrix types.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArnoldiMethod.ArnoldiWorkspace","category":"page"},{"location":"#ArnoldiMethod.ArnoldiWorkspace","page":"Home","title":"ArnoldiMethod.ArnoldiWorkspace","text":"ArnoldiWorkspace(n, k) → ArnoldiWorkspace\nArnoldiWorkspace(v1, k) → ArnoldiWorkspace\nArnoldiWorkspace(V, H; V_tmp, Q) → ArnoldiWorkspace\n\nHolds the large arrays for the Arnoldi relation: Vₖ₊₁ and Hₖ are matrices that satisfy A * Vₖ = Vₖ₊₁ * Hₖ, where Vₖ₊₁ is orthonormal of size n × (k+1) and Hₖ upper  Hessenberg of size (k+1) × k. The matrices V_tmp and Q are used for restarts, and have similar size as Vₖ₊₁ and Hₖ (but Q is k × k, not k+1 × k).\n\nExamples\n\n# allocates workspace for 20-dimensional Krylov subspace\narnoldi = ArnoldiWorkspace(100, 20)\n\n# allocate workspace for 20-dimensional Krylov subspace, with initial vector ones(100) copied into\n# the first column of V\narnoldi = ArnoldiWorkspace(ones(100), 20)\n\n# manually allocate workspace with V, H\nV = Matrix{Float64}(undef, 100, 21)\nH = Matrix{Float64}(undef, 21, 20)\narnoldi = ArnoldiWorkspace(V, H)\n\n# manually allocate all arrays, including temporaries\nV, tmp = Matrix{Float64}(undef, 100, 21), Matrix{Float64}(undef, 100, 21)\nH, Q = Matrix{Float64}(undef, 21, 20), Matrix{Float64}(undef, 20, 20)\narnoldi = ArnoldiWorkspace(V, H, V_tmp = tmp, Q = Q)\n\n\n\n\n\n","category":"type"},{"location":"#Starting-from-an-initial-partial-Schur-decomposition","page":"Home","title":"Starting from an initial partial Schur decomposition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can also use ArnoldiWorkspace to start the algorithm from an initial partial Schur decomposition. This is useful if you already found a few Schur vectors, and want to continue to find more.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = rand(100, 100)\n\n# Pre-allocate the relevant Krylov subspace arrays\nV, H = rand(100, 21), rand(21, 20)\narnoldi = ArnoldiWorkspace(V, H)\n\n# Find a few eigenvalues\n_, info_1 = partialschur!(A, arnoldi, nev = 3, tol = 1e-12)\n\n# Then continue to find a couple more. Notice: 5 in total, so 2 more. Allow larger errors by\n# changin `tol`.\nF, info_2 = partialschur!(A, arnoldi, nev = 5, start_from = info_1.nconverged + 1 , tol = 1e-8)\n@show norm(A * F.Q - F.Q * F.R)","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Setting `start_from` correctly\nAs pointed out above, in real arithmetic the algorithm may find one eigenvalue more than requested if it corresponds to a conjugate pair. Also it may find fewer, if not all converge. So if you reuse your ArnoldiWorkspace, make sure to set start_from to one plus the number of previously converged eigenvalues.","category":"page"},{"location":"#What-algorithm-is-ArnoldiMethod.jl?","page":"Home","title":"What algorithm is ArnoldiMethod.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The underlying algorithm is the restarted Arnoldi method, which be viewed as a mix between a subspace accelerated version of the power method and a truncated  version of the dense QR algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Initially the method was based on the Implicitly Restarted Arnoldi Method (or IRAM for short), which is the algorithm implemented by ARPACK. This method has a very elegant restarting scheme based on exact QR iterations, but is  unfortunately susceptible to forward instabilities of the QR algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this reason the Krylov-Schur method is currently embraced in this package, which is mathematically equivalent to IRAM, but has better stability by  replacing exact QR iterations with a direct method that reorders the Schur form. In fact we see Krylov-Schur just as an implementation detail of the Arnoldi  method.","category":"page"},{"location":"#Bringing-problems-to-standard-form","page":"Home","title":"Bringing problems to standard form","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ArnoldiMethod.jl by default can only compute an approximate, partial Schur decomposition AQ = QR and (from there) a partial eigendecomposition AX = XD of a matrix A, for extremal eigenvalues d_ii. These are eigenvalues at the boundary of the convex hull of the spectrum of A. Search targets for eigenvalues are: large magnitude, and large or small real or imaginary parts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Whenever one targets eigenvalues close to a specific point in the complex plane, or whenever one solves generalized eigenvalue problems, suitable transformations will enable you to recast the problem into something that ArnoldiMethod.jl can  handle well. In this section we provide some examples.","category":"page"},{"location":"#Shift-and-invert-with-LinearMaps.jl","page":"Home","title":"Shift-and-invert with LinearMaps.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To find eigenvalues closest to the origin of A, one can find the eigenvalues of largest magnitude of A^-1. LinearMaps.jl  is a neat way to implement this.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ArnoldiMethod, LinearAlgebra, LinearMaps\n\n# Define a matrix whose eigenvalues you want\nA = rand(100,100)\n\n# Factorizes A and builds a linear map that applies inv(A) to a vector.\nfunction construct_linear_map(A)\n    F = factorize(A)\n    LinearMap{eltype(A)}((y, x) -> ldiv!(y, F, x), size(A,1), ismutating=true)\nend\n\n# Target the largest eigenvalues of the inverted problem\ndecomp, = partialschur(construct_linear_map(A), nev=4, tol=1e-5, restarts=100, which=:LM)\nλs_inv, X = partialeigen(decomp)\n\n# Eigenvalues have to be inverted to find the smallest eigenvalues of the non-inverted problem.\nλs = 1 ./ λs_inv\n \n# Show that Ax = xλ\n@show norm(A * X - X * Diagonal(λs)) # 7.38473677258669e-6","category":"page"},{"location":"#Shift-and-invert-for-generalized-eigenvalue-problems","page":"Home","title":"Shift-and-invert for generalized eigenvalue problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When targeting the eigenvalues closest to the origin of a generalized eigenvalue problem Ax = Bxlambda, one can apply the shift-and-invert trick, recasting  the problem to A^-1Bx = xtheta where lambda = 1  theta.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ArnoldiMethod, LinearAlgebra, LinearMaps\n\n# Define the matrices of the generalized eigenvalue problem\nA, B = rand(100, 100), rand(100, 100)\n\nstruct ShiftAndInvert{TA,TB,TT}\n    A_lu::TA\n    B::TB\n    temp::TT\nend\n\nfunction (M::ShiftAndInvert)(y, x)\n    mul!(M.temp, M.B, x)\n    ldiv!(y, M.A_lu, M.temp)\nend\n\nfunction construct_linear_map(A, B)\n    a = ShiftAndInvert(factorize(A), B, Vector{eltype(A)}(undef, size(A, 1)))\n    LinearMap{eltype(A)}(a, size(A, 1), ismutating = true)\nend\n\n# Target the largest eigenvalues of the inverted problem\ndecomp, = partialschur(\n    construct_linear_map(A, B),\n    nev = 4,\n    tol = 1e-5,\n    restarts = 100,\n    which = :LM,\n)\nλs_inv, X = partialeigen(decomp)\n\n# Eigenvalues have to be inverted to find the smallest eigenvalues of the non-inverted problem.\nλs = 1 ./ λs_inv\n\n# Show that Ax = Bxλ\n@show norm(A * X - B * X * Diagonal(λs)) # 2.8043149027575927e-6","category":"page"},{"location":"#Largest-eigenvalues-of-a-generalized-eigenvalue-problem-with-symmetric-positive-definite-B","page":"Home","title":"Largest eigenvalues of a generalized eigenvalue problem with symmetric positive-definite B","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When B is a symmetric positive-definite matrix, and it's affordable to compute a Cholesky decomposition of B, one can use ArnoldiMethod.jl to create a partial Schur decomposition of A where the Schur vectors are B-orthonormal:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solve Q^*AQ = R where Q^*BQ = I and R is upper triangular. If A = A^* as well, then R is diagonal and we have a partial eigendecomposition of A.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First we take the Cholesky decomposition B = LL^* and plug it into AQ = BQR to obtain L^-*AL^-1L^*Q = L^*QR.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then define C = L^-*AL^-1 and Y = L^*Q and we have a standard Schur decomposition CY = YR which we can solve using partialschur.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The linear map C can be defined as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ArnoldiMethod, LinearAlgebra, LinearMaps\nstruct WithBInnerProduct{TA,TL}\n    A::TA\n    L::TL\nend\n\nfunction (M::WithBInnerProduct)(y, x)\n    # Julia unfortunately does not have in-place CHOLMOD solve, so this is far from optimal.\n    tmp = M.L \\ x\n    mul!(y, M.A, tmp)\n    y .= M.L' \\ y\n    return y\nend\n\n# Define the matrices of the generalized eigenvalue problem\nA = rand(100, 100)\nB = Diagonal(range(1.0, 2.0, length = 100))\n\n# Reformulate the problem as standard Schur decomposition\nF = cholesky(B)\nlinear_map = LinearMap{eltype(A)}(WithBInnerProduct(A, F.L), size(A, 1), ismutating = true)\ndecomp, info = partialschur(linear_map, nev = 4, which = :LM, tol = 1e-10)\n\n# Translate back to the original problem\nQ = F.L' \\ decomp.Q\n\n@show norm(Q' * A * Q - decomp.R)  # 3.883933945390996e-14\n@show norm(Q' * B * Q - I)  # 3.1672155003480583e-15","category":"page"},{"location":"#Goal-of-this-package:-an-efficient,-pure-Julia-implementation","page":"Home","title":"Goal of this package: an efficient, pure Julia implementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project started with two goals:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Having a native Julia implementation of the eigs function that performs as well as ARPACK. With native we mean that its implementation should be generic and support any number type. Currently the partialschur function does not depend on LAPACK, it even has its own implementation of a dense eigensolver.\nRemoving the dependency of the Julia language on ARPACK. This goal was already achieved before the package was stable enough, since ARPACK moved to a separate repository Arpack.jl.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ArnoldiMethod.jl should be roughly on par with Arpack.jl, and slightly faster than KrylovKit.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Do note that for an apples to apples comparison, it's important to compare with identical defaults: each of the mentioned packages uses a slightly different default convergence criterion.","category":"page"},{"location":"#Status","page":"Home","title":"Status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An overview of what we have, how it's done and what we're missing.","category":"page"},{"location":"#Implementation-details","page":"Home","title":"Implementation details","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The method does not make assumptions about the type of the matrix; it is  matrix-free.\nConverged Ritz vectors are locked (or deflated).\nWe may do \"purging\" differently from ARPACK: in ArnoldiMethod.jl it is rather \"unlocking\", in the sense that converged but unwanted eigenvectors are retained in the search subspace instead of removed from it.\nImportant matrices and vectors are pre-allocated and operations on the  Hessenberg matrix are in-place; Julia's garbage collector can sit back.\nKrylov basis vectors are orthogonalized with repeated classical Gram-Schmidt to ensure they are orthogonal up to machine precision; this is a BLAS-2 operation.\nTo compute the Schur decomposition of the Hessenberg matrix we use a dense  QR algorithm written natively in Julia. It is based on implicit (or Francis)  shifts and handles real arithmetic efficiently.\nLocking and purging of Ritz vectors is done by reordering the Schur form,  which is also implemented natively in Julia. In the real case it is done by casting tiny Sylvester equations to linear systems and solving them with  complete pivoting.\nShrinking the size of the Krylov subspace and changing its basis is done by accumulating all rotations and reflections in a unitary matrix Q, and then simply computing the matrix-matrix product V := V * Q, where V is the  original orthonormal basis. This is not in-place in V, so we allocate a bit of scratch space ahead of time.","category":"page"},{"location":"#Not-implemented","page":"Home","title":"Not implemented","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Being able to kickstart the method from a given Arnoldi relation. This also captures:\nMaking an initial guess by providing a known approximate eigenvector;\nDeflating some subspace by starting the Arnoldi method with a given partial Schur decomposition.\nMatrix-induced inner product for generalized eigenvalue problems.\nEfficient implementation of symmetric problems with Lanczos.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On my wish list is to allow custom vector or matrix types, so that we can  delegate expensive but trivial work to hardware that can do it faster  (distributed memory / GPU). The basic concept would be: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core Arnoldi method performs tedious linear algebra on the projected,  low-dimensional problem, but finally just outputs a change of basis in the form of a unitary matrix Q.\nAppropriate hardware does the change of basis V := V * Q.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similar things should happen for expansion of the subspace and  orthogonalization.","category":"page"}]
}
